package main

// Code generated by typedreplay. DO NOT EDIT.

import (
	"context"
	"time"

	"github.com/corverroos/replay"
	"github.com/golang/protobuf/proto"
	"github.com/luno/reflex"
	// TODO(corver): Support importing other packages.
)

const (
	_ns      = "09_parentjob"
	_wParent = "parent"
)

type parentSignal int

const (
	_sParentClaimJob    parentSignal = 1
	_sParentCompleteJob parentSignal = 2
)

var parentSignalMessages = map[parentSignal]proto.Message{
	_sParentClaimJob:    new(ClaimJob),
	_sParentCompleteJob: new(CompleteJob),
}

func (s parentSignal) SignalType() int {
	return int(s)
}

func (s parentSignal) MessageType() proto.Message {
	return parentSignalMessages[s]
}

// SignalParentClaimJob provides a typed API for signalling a parent workflow run with signal claim_job.
// It returns true on success or false on duplicate calls or an error.
func SignalParentClaimJob(ctx context.Context, cl replay.Client, run string, message *ClaimJob, extID string) (bool, error) {
	return cl.SignalRun(ctx, _ns, _wParent, run, _sParentClaimJob, message, extID)
}

// SignalParentCompleteJob provides a typed API for signalling a parent workflow run with signal complete_job.
// It returns true on success or false on duplicate calls or an error.
func SignalParentCompleteJob(ctx context.Context, cl replay.Client, run string, message *CompleteJob, extID string) (bool, error) {
	return cl.SignalRun(ctx, _ns, _wParent, run, _sParentCompleteJob, message, extID)
}

// RunParent provides a type API for running the parent workflow.
// It returns true on success or false on duplicate calls or an error.
func RunParent(ctx context.Context, cl replay.Client, run string, message *JobRequest) (bool, error) {
	return cl.RunWorkflow(ctx, _ns, _wParent, run, message)
}

// startReplayLoops registers the workflow and activities for typed workflow functions.
func startReplayLoops(getCtx func() context.Context, cl replay.Client, cstore reflex.CursorStore, b Backends,
	parent func(parentFlow, *JobRequest)) {

	parentFunc := func(ctx replay.RunContext, message *JobRequest) {
		parent(parentFlowImpl{ctx}, message)
	}
	replay.RegisterWorkflow(getCtx, cl, cstore, _ns, parentFunc, replay.WithName(_wParent))

}

// parentFlow defines a typed API for the parent workflow.
type parentFlow interface {

	// Sleep blocks for at least d duration.
	// Note that replay sleeps aren't very accurate and
	// a few seconds is the practical minimum.
	Sleep(d time.Duration)

	// CreateEvent returns the reflex event that started the run iteration (type is internal.CreateRun).
	// The event timestamp could be used to reason about run age.
	CreateEvent() *reflex.Event

	// LastEvent returns the latest reflex event (type is either internal.CreateRun or internal.ActivityResponse).
	// The event timestamp could be used to reason about run liveliness.
	LastEvent() *reflex.Event

	// Now returns the last event timestamp as the deterministic "current" time.
	// It is assumed the first time this is used in logic it will be very close to correct while
	// producing deterministic logic during bootstrapping.
	Now() time.Time

	// Run returns the run name/identifier.
	Run() string

	// Restart completes the current run iteration and starts a new run iteration with the provided input message.
	// The run state is effectively reset. This is handy to mitigate bootstrap load for long running tasks.
	// It also allows updating the activity logic/ordering.
	Restart(message *JobRequest)

	// AwaitClaimJob blocks and returns true when a claim_job signal is/was
	// received for this run. If no signal is/was received it returns false after d duration.
	AwaitClaimJob(d time.Duration) (*ClaimJob, bool)

	// AwaitCompleteJob blocks and returns true when a complete_job signal is/was
	// received for this run. If no signal is/was received it returns false after d duration.
	AwaitCompleteJob(d time.Duration) (*CompleteJob, bool)
}

type parentFlowImpl struct {
	ctx replay.RunContext
}

func (f parentFlowImpl) Sleep(d time.Duration) {
	f.ctx.Sleep(d)
}

func (f parentFlowImpl) CreateEvent() *reflex.Event {
	return f.ctx.CreateEvent()
}

func (f parentFlowImpl) LastEvent() *reflex.Event {
	return f.ctx.LastEvent()
}

func (f parentFlowImpl) Now() time.Time {
	return f.ctx.LastEvent().Timestamp
}

func (f parentFlowImpl) Run() string {
	return f.ctx.Run()
}

func (f parentFlowImpl) Restart(message *JobRequest) {
	f.ctx.Restart(message)
}

func (f parentFlowImpl) AwaitClaimJob(d time.Duration) (*ClaimJob, bool) {
	res, ok := f.ctx.AwaitSignal(_sParentClaimJob, d)
	if !ok {
		return nil, false
	}
	return res.(*ClaimJob), true
}

func (f parentFlowImpl) AwaitCompleteJob(d time.Duration) (*CompleteJob, bool) {
	res, ok := f.ctx.AwaitSignal(_sParentCompleteJob, d)
	if !ok {
		return nil, false
	}
	return res.(*CompleteJob), true
}

// StreamParent returns a stream of replay events for the parent workflow and an optional run.
func StreamParent(cl replay.Client, run string) reflex.StreamFunc {
	return cl.Stream(_ns, _wParent, run)
}

// HandleParentRun calls fn if the event is a parent RunCreated event.
// Use StreamParent to provide the events.
func HandleParentRun(e *reflex.Event, fn func(run string, message *JobRequest) error) error {
	return replay.Handle(e,
		replay.HandleSkip(func(namespace, workflow, run string) bool {
			return namespace != _ns || workflow != _wParent
		}),
		replay.HandleRunCreated(func(namespace, workflow, run string, message proto.Message) error {
			return fn(run, message.(*JobRequest))
		}),
	)
}
